using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SG.Generator
{
    [Generator]
    public class ToJsonGenerator : IIncrementalGenerator
    {
        private const string HelloWorld = """
                                          using System;

                                          namespace SG.Generator;

                                          [AttributeUsage(AttributeTargets.Class)]
                                          public class ToJsonSerializerAttribute : Attribute;
                                          """;
        
        private const string PartialClassTemplate = """
                                                    //---------------------------------------------------
                                                    // <auto-generated>
                                                    //    This code was generated by ToJsonGenerator{{generatedAt}}.
                                                    // </auto-generated>
                                                    //---------------------------------------------------
                                                        
                                                        using System.Text;
                                                        
                                                        namespace {{namespace}}
                                                        {
                                                            {{classAccessibility}} partial class {{className}}
                                                            {
                                                                public string ToJson()
                                                                {
                                                                    var builder = new StringBuilder();
                                                                    
                                                                    builder.AppendLine("{");
                                                                    {{properties}}
                                                                    builder.AppendLine("}");
                                                                    
                                                                    return builder.ToString();
                                                                }
                                                            }
                                                        }
                                                    """;
        private const string PropertyTemplate = """
                                                builder.AppendLine($"\t\"{{name}}\": \"{{{name}}}\",");
                                                """;

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // #if DEBUG
            // if (!System.Diagnostics.Debugger.IsAttached)
            // {
            //     System.Diagnostics.Debugger.Launch();
            // }
            // #endif

            context.RegisterPostInitializationOutput(ctx =>
                ctx.AddSource("ToJsonSerializerAttribute.g.cs", SourceText.From(HelloWorld, Encoding.UTF8)));

            var provider = context.SyntaxProvider.CreateSyntaxProvider(Predicate, Transform)
                .Where(x => x != null);
            
            context.RegisterSourceOutput(provider, Generate);
        }

        private void Generate(SourceProductionContext context, ClassInfo? classInfo)
        {
            if (classInfo is null)
                return;

            var builder = new StringBuilder();
            foreach (var property in classInfo.Value.Properties)
            {
                var propertyTemplate = PropertyTemplate.Replace("{{name}}", property.Name);
                builder.AppendLine(propertyTemplate);
            }
            
            var properties = builder.ToString(0, builder.Length - 6) + "\");";
            
            var output = PartialClassTemplate
                .Replace("{{namespace}}", classInfo.Value.Namespace)
                .Replace("{{className}}", classInfo.Value.Name)
                #if DEBUG
                .Replace("{{generatedAt}}", $" at {DateTime.Now:T}")
                #else
                .Replace("{{generatedAt}}", string.Empty)
                #endif
                .Replace("{{classAccessibility}}", classInfo.Value.Accessibility.ToString().ToLower())
                .Replace("{{properties}}", properties);
            
            context.AddSource($"{classInfo.Value.Name}.g.cs", output);
        }

        private ClassInfo? Transform(GeneratorSyntaxContext arg1, CancellationToken ct)
        {
            var classDeclarationSyntax = (ClassDeclarationSyntax)arg1.Node;

            foreach (var attributeList in classDeclarationSyntax.AttributeLists)
            {
                foreach (var attributeSyntax in attributeList.Attributes)
                {
                    if (ct.IsCancellationRequested)
                        return null;
                    
                    var attributeName = attributeSyntax.Name.ToString();
                    if (attributeName != "ToJsonSerializer" && attributeName != "ToJsonSerializerAttribute") continue;
                    
                    var attributeSymbolInfo = arg1.SemanticModel.GetSymbolInfo(attributeSyntax, ct);
                    
                    if (attributeSymbolInfo.Symbol is not IMethodSymbol methodSymbol) continue;
                    
                    var attributeSymbol = methodSymbol.ContainingType;
                    if (attributeSymbol.Name != "ToJsonSerializerAttribute" &&
                        attributeSymbol.Name != "ToJsonSerializer") 
                        continue;
                    
                    var classSymbol = arg1.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax, ct);
                    
                    var classInfo = new ClassInfo()
                    {
                        Namespace = classSymbol?.ContainingNamespace.ToString(),
                        Name = classSymbol?.Name,
                        Accessibility = classSymbol?.DeclaredAccessibility,
                        Properties = GetProperties(classSymbol)
                    };

                    return classInfo;
                }
            }
            
            return null;
        }

        private static IEnumerable<PropertyInfo> GetProperties(ISymbol? classSymbol)
        {
            if (classSymbol is not INamedTypeSymbol namedTypeSymbol)
                return [];
            
            var properties = namedTypeSymbol.GetMembers().OfType<IPropertySymbol>()
                .OrderBy(p => p.Name)
                .Select(p => new PropertyInfo()
            {
                Name = p.Name,
                Accessibility = p.DeclaredAccessibility
            });

            return properties;
        }

        private static bool Predicate(SyntaxNode node, CancellationToken ct)
        {
            return node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };
        }
    }

    public record struct ClassInfo
    {
        public readonly bool Equals(ClassInfo other)
        {
            return Namespace == other.Namespace && 
                   Name == other.Name && 
                   Accessibility == other.Accessibility && 
                   Properties.SequenceEqual(other.Properties); // checks if the items in the collection are equal
        }

        public readonly override int GetHashCode()
        {
            var hashCode = Accessibility?.GetHashCode() ?? 0;
            hashCode = (hashCode * 397) ^ (Namespace?.GetHashCode() ?? 0);
            hashCode = (hashCode * 397) ^ (Name?.GetHashCode() ?? 0);
            hashCode = (hashCode * 397) ^ Properties.Aggregate(hashCode, (current, property) => (current ^ current + 397) ^ property.GetHashCode());
            return hashCode;
        }

        public string? Namespace { get; set; }
        public string? Name { get; set; }
        public Accessibility? Accessibility { get; set; }
        public IEnumerable<PropertyInfo> Properties { get; set; }
    }
    
    public record struct PropertyInfo
    {
        public string? Name { get; set; }
        public Accessibility? Accessibility { get; set; }
    }
}

/*
T:System.Console; Analyzers should not be reading / writing to the console
T:System.Diagnostics.Process; Analyzers should not inspect or create processes
T:System.Diagnostics.ProcessStartInfo; Analyzers should not inspect or create processes
T:System.Environment; Analyzers should not read their settings directly from environment variables
P:System.Globalization.CultureInfo.CurrentCulture; Analyzers should use LocalizableResourceString for culture-dependent messages
P:System.Globalization.CultureInfo.CurrentUICulture; Analyzers should use LocalizableResourceString for culture-dependent messages
T:System.IO.File; Do not do file IO in analyzers
T:System.IO.Directory; Do not do file IO in analyzers
M:System.IO.Path.GetTempPath; Do not do file IO in analyzers
T:System.Random; Analyzers should be deterministic
M:System.Reflection.Assembly.Load(System.Byte[]); Analyzers should only load their dependencies via standard runtime mechanisms
M:System.Reflection.Assembly.Load(System.String); Analyzers should only load their dependencies via standard runtime mechanisms
M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName); Analyzers should only load their dependencies via standard runtime mechanisms
M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[]); Analyzers should only load their dependencies via standard runtime mechanisms
T:Microsoft.CodeAnalysis.GeneratorInitializationContext; Non-incremental source generators should not be used, implement IIncrementalGenerator instead
T:Microsoft.CodeAnalysis.GeneratorExecutionContext; Non-incremental source generators should not be used, implement IIncrementalGenerator instead
 */