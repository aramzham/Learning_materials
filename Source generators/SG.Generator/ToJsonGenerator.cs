using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SG.Generator
{
    [Generator]
    public class ToJsonGenerator : IIncrementalGenerator
    {
        private const string ToJsonSerializerAttributeCode = """
                                          using System;

                                          namespace SG.Generator;

                                          [AttributeUsage(AttributeTargets.Class)]
                                          public class ToJsonSerializerAttribute : Attribute
                                          {
                                              public bool Minified { get; }
                                              public Type TargetType { get; }
                                              
                                              public ToJsonSerializerAttribute(Type targetType, bool minified = false)
                                              {
                                                  Minified = minified;
                                                  TargetType = targetType;
                                              }
                                          }
                                          """;
        
        private const string PartialClassTemplate = """
                                                    //---------------------------------------------------
                                                    // <auto-generated>
                                                    //    This code was generated by ToJsonGenerator{{generatedAt}}.
                                                    // </auto-generated>
                                                    //---------------------------------------------------
                                                        
                                                        using System.Text;
                                                        
                                                        namespace {{namespace}}
                                                        {
                                                            {{classAccessibility}} partial class {{className}}
                                                            {
                                                                public string ToJson()
                                                                {
                                                                    var builder = new StringBuilder();
                                                                    
                                                                    builder.{{appendLine}}("{");
                                                                    {{properties}}
                                                                    builder.{{appendLine}}("}");
                                                                    
                                                                    return builder.ToString();
                                                                }
                                                            }
                                                        }
                                                    """;
        private const string PropertyTemplate = """
                                                builder.{{appendLine}}($"{{space}}{{space}}\"{{name}}\":{{space}}\"{{{name}}}\",");
                                                """;

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // #if DEBUG
            // if (!System.Diagnostics.Debugger.IsAttached)
            // {
            //     System.Diagnostics.Debugger.Launch();
            // }
            // #endif

            context.RegisterPostInitializationOutput(ctx =>
                ctx.AddSource("ToJsonSerializerAttribute.g.cs", SourceText.From(ToJsonSerializerAttributeCode, Encoding.UTF8)));

            // var provider = context.SyntaxProvider.CreateSyntaxProvider(Predicate, Transform)
            //     .Where(x => x != null);
            var provider = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    "SG.Generator.ToJsonSerializerAttribute",
                    (node, ct) => true,
                    Transform);
            
            context.RegisterSourceOutput(provider, Generate);
        }

        private void Generate(SourceProductionContext context, ClassInfo classInfo)
        {
            var builder = new StringBuilder();
            foreach (var property in classInfo.Properties)
            {
                var propertyTemplate = PropertyTemplate
                    .Replace("{{name}}", property.Name)
                    .Replace("{{space}}", classInfo.Minified ? string.Empty : " ")
                    .Replace("{{appendLine}}", classInfo.Minified ? "Append" : "AppendLine");
                builder.AppendLine(propertyTemplate);
            }
            
            var properties = builder.ToString(0, builder.Length - 6) + "\");";
            
            var output = PartialClassTemplate
                .Replace("{{namespace}}", classInfo.Namespace)
                .Replace("{{className}}", classInfo.Name)
                #if DEBUG
                .Replace("{{generatedAt}}", $" at {DateTime.Now:T}")
                #else
                .Replace("{{generatedAt}}", string.Empty)
                #endif
                .Replace("{{classAccessibility}}", classInfo.Accessibility.ToString().ToLower())
                .Replace("{{properties}}", properties)
                .Replace("{{space}}", classInfo.Minified ? string.Empty : " ")
                .Replace("{{appendLine}}", classInfo.Minified ? "Append" : "AppendLine");
            
            context.AddSource($"{classInfo.Name}.g.cs", output);
        }

        private ClassInfo Transform(GeneratorAttributeSyntaxContext syntaxContext, CancellationToken ct)
        {
            var attribute = syntaxContext.Attributes.Single();
            var targetType = attribute.ConstructorArguments[0].Value as ISymbol;
            var minified = attribute.ConstructorArguments[1].Value as bool? is true;
            var classDeclarationSyntax = (ClassDeclarationSyntax)syntaxContext.TargetNode;
            var classSymbol = syntaxContext.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax, ct);

            var classInfo = new ClassInfo()
            {
                Namespace = targetType?.ContainingNamespace.ToString(),
                Name = targetType?.Name,
                Accessibility = targetType?.DeclaredAccessibility,
                Properties = GetProperties(classSymbol),
                Minified = minified
            };

            return classInfo;
        }

        private static IEnumerable<PropertyInfo> GetProperties(ISymbol? classSymbol)
        {
            if (classSymbol is not INamedTypeSymbol namedTypeSymbol)
                return [];
            
            var properties = namedTypeSymbol.GetMembers().OfType<IPropertySymbol>()
                .OrderBy(p => p.Name)
                .Select(p => new PropertyInfo()
            {
                Name = p.Name,
                Accessibility = p.DeclaredAccessibility
            });

            return properties;
        }
    }

    public record struct ClassInfo
    {
        public readonly bool Equals(ClassInfo other)
        {
            return Namespace == other.Namespace && 
                   Name == other.Name && 
                   Accessibility == other.Accessibility &&
                   Minified == other.Minified &&
                   Properties.SequenceEqual(other.Properties); // checks if the items in the collection are equal
        }

        public readonly override int GetHashCode()
        {
            var hashCode = Accessibility?.GetHashCode() ?? 0;
            hashCode = (hashCode * 397) ^ Minified.GetHashCode();
            hashCode = (hashCode * 397) ^ (Namespace?.GetHashCode() ?? 0);
            hashCode = (hashCode * 397) ^ (Name?.GetHashCode() ?? 0);
            hashCode = (hashCode * 397) ^ Properties.Aggregate(hashCode, (current, property) => (current ^ current + 397) ^ property.GetHashCode());
            return hashCode;
        }

        public string? Namespace { get; set; }
        public string? Name { get; set; }
        public Accessibility? Accessibility { get; set; }
        public IEnumerable<PropertyInfo> Properties { get; set; }
        public bool Minified { get; set; }
    }
    
    public record struct PropertyInfo
    {
        public string? Name { get; set; }
        public Accessibility? Accessibility { get; set; }
    }
}

/*
T:System.Console; Analyzers should not be reading / writing to the console
T:System.Diagnostics.Process; Analyzers should not inspect or create processes
T:System.Diagnostics.ProcessStartInfo; Analyzers should not inspect or create processes
T:System.Environment; Analyzers should not read their settings directly from environment variables
P:System.Globalization.CultureInfo.CurrentCulture; Analyzers should use LocalizableResourceString for culture-dependent messages
P:System.Globalization.CultureInfo.CurrentUICulture; Analyzers should use LocalizableResourceString for culture-dependent messages
T:System.IO.File; Do not do file IO in analyzers
T:System.IO.Directory; Do not do file IO in analyzers
M:System.IO.Path.GetTempPath; Do not do file IO in analyzers
T:System.Random; Analyzers should be deterministic
M:System.Reflection.Assembly.Load(System.Byte[]); Analyzers should only load their dependencies via standard runtime mechanisms
M:System.Reflection.Assembly.Load(System.String); Analyzers should only load their dependencies via standard runtime mechanisms
M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName); Analyzers should only load their dependencies via standard runtime mechanisms
M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[]); Analyzers should only load their dependencies via standard runtime mechanisms
T:Microsoft.CodeAnalysis.GeneratorInitializationContext; Non-incremental source generators should not be used, implement IIncrementalGenerator instead
T:Microsoft.CodeAnalysis.GeneratorExecutionContext; Non-incremental source generators should not be used, implement IIncrementalGenerator instead
 */