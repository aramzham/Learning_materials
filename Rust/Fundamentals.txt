To begin with Windows download rustup-init.exe (https://www.rust-lang.org/tools/install).
Check if everything installed correctly with 'rustc --version'.
Then install the build tools (rustup toolchain install stable-x86_64-pc-windows-gnu).


For better developer experience download JetBrains IntelliJ with Rust plugin (https://plugins.jetbrains.com/plugin/8182-rust).


Run 'cargo build' to build your project.


Rust is static and strongly typed language.
Static - we know all of the data types of all variables at compile time.
Strong - enforces rules on data type assignments (not pointer friendly).

Compiled language - the compiler takes your source code and compiles to native byte code.
Interpreted language - needs special program called Interpreter to run. An interpreter is a machine-code program compiles or interprets your code on fly while it's running.


8-bit integer
u8 - 0..255
i8 - -128..127


Rust uses 4 byte characters meaning you can store 4,294,967,296 characters in Unicode-32 table, literally any language letter or emoji existing.


Scalar vs Compound data types
scalar means that it holds a single value in a variable, compound stores multiple.
primitive types are those types that exist in language by default (they can be both scalar(like int or bool) or compound(like arrays or tuples)).


Rust has 2 different types for strings:
String(with capital letter) and &str(string slice).
Both are vectors of u8 data.
String is mutable, &str is immutable.
String is stored on the heap because it grow and shrink in size so it cannot be stored on the stack, &str can be stored on the heap, stack or embedded in the compiled code.


Variables in Rust are immutable by default.
It's designed for safety, speed, concurrency. 
If your variable can't change at runtime then multiple threads can use it without locking it.
Plus, the compiler can emit more efficient machine code for them because it knows that the value won't change.


const value cannot be shadowed in comparison to immutable variables.


Rust doesn't have a 'null' data type.


Ownership and borrowing apply to data on the heap only.

There can be 1 and only 1 owner of the data at a given time.

Borrowing allows another variable to take temporary ownership of data without deallocating the original variable.


Traits define shared behavior among structs.
Traits are analogous to interfaces in OOP languages.


VecDeque - shorthand for vector double ended queue.
Can add and remove from the front or the back.
Cannot sort the elements of a VecDeque.


iter() iterates over a collection and cannot change those values.
iter_mut() iterates over a collection and allows changing of those values.


Rust has Hash Maps and Btree Maps.
When you want your keys to be ordered then use Btree Map.


For using generics there's no performance penalty as the <T> placeholder will be replaced by a real type during the compliation.


When you want to combine 2 traits in a single constraint use + like this: fn ops<T>(o1: T, o2: T) -> T where T: Add<Output = T> + Sub<Output = T> { // your code}


Concurrent execution happens on a machine with a single CPU where the task scheduler gives certain time to each thread to execute.

Parallel execution happens when you have multiple CPUs or a single on with many cores where each CPU is doing its own job parallely.


A thread is an independent unit of execution with resources like memory or CPU time allocated to it.
Even if they work in the same program, it's like having 2 different programs running in 1.


When the program ends so do the all threads.


When we compile (rustc) code, the binary that results from compilation is called crate (whether it's a library or an executable).


Use 'cargo clean' to clean the project from build files.
Use 'cargo doc' or 'cargo rustdoc' to generate documentation from code comments (document what and why and not how).


Crates are archived source code files, they are not built files.
That's why you'd need .lock file to correctly build your dependencies.